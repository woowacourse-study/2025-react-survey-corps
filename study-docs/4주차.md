# 4주차 스터디 기록

- 일시 : 2025.06.24
- 참여 인원: 퐁쥬, 머핀, 헤일리, 캉골, 상추, 메타, 해삐

## 목차

- [Ref로 값 참조하기](#Ref로-값-참조하기)
- [Ref로 DOM 조작하기](#Ref로-DOM-조작하기)
- [Effect로 동기화하기](#Effect로-동기화하기)
- [Effect가 필요하지 않은 경우](#Effect가-필요하지-않은-경우)

---

## 📘 Ref로 값 참조하기

### 학습 내용

📌 `useRef`로 값 저장하기

- 컴포넌트 외부의 값(예: 타이머 ID 등)을 저장하는 데 유용하다.
- 렌더링 사이에 값을 유지하지만, 변경되어도 리렌더링을 일으키지 않는다.

📌 ref 값의 업데이트 방식

- `ref.current`로 값을 저장하거나 읽는다.
- 렌더링 중에는 `current` 값을 읽거나 쓰면 안 된다.

📌 Ref vs State

| 항목 | Ref | State |
|------|-----|-------|
| 리렌더링 발생 | ❌ | ✅ |
| 렌더 중 접근 가능 | ❌ | ✅ |
| 반환 형식 | `{ current: value }` | `[value, setValue]` |
| DOM 제어 가능 여부 | 가능 | 불가 |

📌 안전한 Ref 사용법

- 렌더링 중에 `ref.current` 값을 직접 수정하지 않는다.
- 외부 시스템 또는 브라우저 API와의 상호작용에 사용할 때 유용하다.

### ❓ 토론 내용

- 외부 시스템 예시: `setTimeout`, `scrollIntoView`, 비디오 재생 등
- 왜 의존성 배열에 `ref`를 넣지 않아도 되나?
  - `ref` 객체의 참조값이 바뀌지 않기 때문에 `ref.current`의 변화는 React가 감지하지 않음
  - 만약 값의 변화가 중요하면 `useState`를 쓰는 게 맞다

---

## 📘 Ref로 DOM 조작하기

### 학습 내용

📌 DOM 노드 접근

- `ref` 속성을 JSX 요소에 전달하여 React가 관리하는 DOM 노드를 참조할 수 있음
  ```jsx
  const myRef = useRef(null);
  <div ref={myRef} />
  ```

📌 다른 컴포넌트의 DOM 접근

- 부모가 `ref`를 생성하고 자식 컴포넌트에 전달하는 방식으로 제어 가능

📌 언제 React DOM을 수정해도 괜찮은가?

- React가 해당 DOM을 **렌더링 결과로 변경하지 않는 경우**에 한해 가능
  - 예: 빈 `<div>` 내부에 외부 라이브러리로 DOM 삽입하는 경우

📌 주의할 점

- React가 DOM을 제어하는 중간에 `ref`로 직접 수정하면 **Virtual DOM과 실제 DOM이 불일치할 수 있음**

### 💡 토론 내용

- useEffect로 DOM 접근할 때 주의할 점
  - `ref`는 안정적인 객체이기 때문에 `ref.current`의 변경은 의존성 배열에 넣지 않아도 됨
  - 그러나 부모에서 받은 `ref`는 props라면 바뀔 수 있으므로 의존성 배열에 포함 필요

---

## 📘 Effect로 동기화하기

### 학습 내용

📌 Effect란?

- 렌더링 자체에 의해 발생하는 **부수효과**를 다루는 Hook
- 예: API 호출, 이벤트 리스너 등록, 타이머 설정 등

📌 이벤트와의 차이점

- **이벤트 핸들러**: 사용자 상호작용으로 발생
- **Effect**: 컴포넌트의 렌더링 자체로 발생

📌 Effect 사용법

```js
useEffect(() => {
  // 부수효과
  return () => {
    // 클린업
  };
}, [deps]);
```

📌 불필요한 Effect 재실행 방지

- 의존성 배열로 지정
- 클린업 함수로 메모리 누수 방지

📌 개발 중 useEffect가 두 번 실행되는 이유

- React의 Strict Mode에서 effect를 한 번 더 실행하여 부수효과 검증을 돕기 때문

---

## 📘 Effect가 필요하지 않은 경우

### 학습 내용

📌 언제 useEffect가 **불필요**한가?

1. 단순 값 변환만 필요한 경우
2. 사용자 이벤트에 직접 반응하는 경우
3. 외부 시스템을 건드릴 필요가 없는 경우

📌 대체 방안

- `useMemo`: 값비싼 계산 캐시
- `useCallback`: 안정적인 함수 전달
- 이벤트 핸들러 내부에 로직 작성

📌 이벤트 핸들러와 Effect의 역할 구분

| 목적 | 사용처 |
|------|--------|
| 사용자 상호작용 처리 | 이벤트 핸들러 |
| 외부 시스템과의 상호작용 | useEffect |

📌 부모 컴포넌트에 변경 알리기

- 상태 끌어올리기 (`lifting state up`)

### 💡 토론 내용

- `ref.current`의 변경은 감지되지 않음 → `useEffect` 의존성 배열에 넣지 않아도 됨
- 하지만 `ref` 객체 자체가 prop으로 전달되는 경우라면, **참조값이 바뀔 수 있으므로** 의존성 배열에 넣어야 함

# 1주차 스터디 기록

- 일시 : 2025.05.01
- 참여 인원 : 퐁쥬, 머핀, 헤일리, 캉골, 상추, 메타, 해삐

## 목차

- [첫 번째 컴포넌트](#첫-번째-컴포넌트)
- [컴포넌트 Import 및 Export 하기](#컴포넌트-import-및-export-하기)
- [JSX로 마크업 작성하기](#jsx로-마크업-작성하기)
- [중괄호 있는 JSX 안에서 자바스크립트 사용하기](#중괄호-있는-jsx-안에서-자바스크립트-사용하기)
- [컴포넌트에 Props 전달하기](#컴포넌트에-props-전달하기)
- [조건부 렌더링](#조건부-렌더링)
- [리스트 렌더링](#리스트-렌더링)
- [컴포넌트를 순수하게 유지하기](#컴포넌트를-순수하게-유지하기)
- [트리로서 UI 이해하기](#트리로서-ui-이해하기)
- [다음주까지](#다음주까지)

---

## [첫 번째 컴포넌트](https://ko.react.dev/learn/your-first-component)

### 학습 내용

### ✅ 학습 내용 요약

#### 📌 컴포넌트란?

- 마크업으로 출력 가능한 자바스크립트 함수
- 애플리케이션의 **재사용 가능한 UI 단위**
- **순수성**(동일한 입력 → 동일한 출력)을 가짐

#### 📌 React 애플리케이션에서 컴포넌트의 역할

- UI 요소를 독립적으로 구성하고 관리
- 전체 UI를 구성하는 기본 단위
- `props`를 받아 순수하게 렌더링되는 함수로 동작

#### 📌 첫 번째 React 컴포넌트 작성 방식

- 기본적으로 함수형 컴포넌트를 정의하고 JSX를 반환

---

### ❓ React는 컴포넌트로만 이루어진 것일까?

_훅(Hook)이나 유틸리티 함수는 컴포넌트에 해당할까?_

#### 📎 토론 내용

1. **훅과 유틸은 컴포넌트가 아니다**

   - 렌더 트리(Render Tree)에는 나타나지 않음
   - 모듈 의존성 트리에는 존재할 수 있음
   - **JSX를 반환하지 않기 때문**

2. **JSX가 없는 함수는 컴포넌트가 아니다**

   - 시각적으로 렌더링할 수 있는 결과가 필요

3. **UI가 없는 컴포넌트도 존재한다 (Headless Component)**
   - 대표적인 예: 상태 로직만 포함된 컴포넌트
   - UI는 없지만 `children`을 통해 UI를 주입받아 동작

#### 🧠 결론

컴포넌트의 정의와 범위에 대해 구체적으로 생각해보고, 2주차 스터디에서 서브미션으로 다루기

---

## [컴포넌트 Import 및 Export 하기](https://ko.react.dev/learn/importing-and-exporting-components)

### 학습 내용

### ✅ 학습 내용 요약

#### 📌 Root 컴포넌트란?

- 최상위 컴포넌트이다. (<-> 리프 컴포넌트 (자식이 없는 맨 아래 컴포넌트))
- React에서 root가 여러 개가 존재할 수도 있음. 하지만 일반적인 구조는 아니다.

#### 📌 컴포넌트를 import 하거나 export 하는 방법

- import 할 때, {}를 이해하게 되었음.
- default vs Named Export

#### 📌 파일 확장자 관련

- 확장자를 붙이고 안붙이는 경우가 존재한다.
- vite build가 확장자를 추가하여 알아서 찾아주기 때문에 확장자를 붙이지 않아도 된다.
  - 미션 초장기 때, js 확장자를 붙이지 않으면 오류가 발생하는 경우가 존재 -> 지금은 vite가 자동으로 붙여줘서 에러가 발생하지 않는다.
- 하지만, ESModule 표준에서는 명시적으로 확장자를 써주는 것이 명확하고 호환성이 좋다.
- React 애플리케이션 개발 시 보통 Webpack, Parcel, Vite 같은 빌드 도구를 사용한다.
  이러한 빌드 도구들은 개발 편의성을 위해 특정 확장자(js, jsx, ts, tsx 등)을 생략해도 알아서 찾아준다.
- 빌드 도구 덕분에 확장자를 제거해도 정상적으로 동작하지만, 표준 JavaScript 모듈(ES Modules) 관점에서 보면 확장자를 포함하는 게 더 낫다.

#### 📌 한 파일에서 여러 컴포넌트를 import 하거나 export 하는 방법

#### 📌 여러 컴포넌트를 여러 파일로 분리하는 방법

---

### ❓ React에서 여러 개가 존재할 수도 있나요?

#### 📎 토론 내용

```javascript
function Greeting() {
  return (
    <div className="greeting">
      <h1>Hello, World!</h1>
      <p>Welcome to the React Survey Test.</p>
    </div>
  );
}

function App() {
  const element = document.getElementById("root");
  const element1 = document.getElementById("root1");
  const element2 = document.getElementById("root2");

  if (!element) {
    return;
  }

  const root1 = ReactDOM.createRoot(element);
  const root2 = ReactDOM.createRoot(element1);
  const root3 = ReactDOM.createRoot(element2);

  root1.render(<Greeting />);
  root2.render(<Greeting />);
  root3.render(<Greeting />);
}

export default App;
```

React에서 root를 여러개 생성하는 것 자체는 가능하나, 일반적인 구조가 아니다.

### ❓ 언제 default / named imports / export를 사용하면 좋을까?

#### 📎 토론 내용

1. 파일 내에서 여러 개를 내보내야 한다면, named export를 사용한다.
2. 컴포넌트는 default로, 그 외 함수나 상수는 named export를 사용한다.
3. 상수 파일은 하나만 있어도 named export를 사용한다.
4. 컨벤션에 따라 다른 것 같다.
5. 어떤 방식을 사용하든 네이밍을 하는 것이 중요하다.

### ❓ 하나의 파일에서 여러개의 컴포넌트를 만들어서 쓰는 경험들이 많은가요?

#### 📎 토론 내용

웬만하면 각각을 분리하는 것 같다.

---

## [JSX로 마크업 작성하기](https://ko.react.dev/learn/writing-markup-with-jsx)

### 학습 내용

### ✅ 학습 내용 요약

#### 📌 React에서 마크업과 렌더링 로직을 같이 사용하는 이유

- 웹이 인터랙티브하게 진화하면서 **동작(로직)**이 **UI 구조(HTML)**를 결정하게 됨.
- JavaScript가 HTML을 제어하게 되었고,
- 마크업과 로직이 분리보다는 공존하는 방식이 더 자연스러워짐.
- 그 흐름 속에서 등장한 것이 React, 그리고 이를 더 직관적으로 다루기 위한 JSX.

#### 📌 JSX와 HTML의 차이점

- JS를 문법으로 쓸 수 있냐 없냐
- JSX는 JS 객체로 변환되기 때문에 문법적 차이가 있음
  - class → className
  - for → htmlFor
  - 이벤트 핸들러 → onClick, onChange 등 카멜케이스 사용
- JSX와 JS가 일대일 대응이 된다.
- 단, `aria-*`와 `data-*`는 예외

#### 📌 JSX로 정보를 보여주는 방법

---

### ❓ JSX가 필수일까? React와 세트의 개념일까?

#### 📎 토론 내용

- React는 선언형을 좋아한다. 그래서 JSX를 쓰긴한다.
- 하지만, JSX 자체를 쓰지 않아도 문제는 없다.
- JSX는 JSX고, React는 React이다. JSX는 syntacic sugar일 뿐.
- 선언형으로 쓰고 싶어서 JSX를 사용한다.
- 실제로는 React 내부에서 JS를 써도 상관 없다.
- JSX는 하나의 문법이다 (JS가 확장된)

#### 🧠 결론

JSX와 React는 별개의 개념이다. JSX는 React를 더 직관적으로 다루기 위한 도구이며, 반드시 함께 써야 하는 것은 아니다.

---

## [중괄호 있는 JSX 안에서 자바스크립트 사용하기](https://ko.react.dev/learn/javascript-in-jsx-with-curly-braces)

---

## [컴포넌트에 Props 전달하기](https://ko.react.dev/learn/passing-props-to-a-component)

### ❓ 컴포넌트의 식별자 역할은 key가 담당한다. 그렇다면, 모든 컴포넌트에는 key 값이 존재해야 하는가?

_단일 컴포넌트에도 key값이 지정되는가?_

#### 📎 토론 내용

- **리스트 렌더링(map 등)** 을 할 때는 각 항목에 key를 반드시 지정해야 한다.
- 리스트 렌더링에서는 key를 부여해주어야 한다. 리스트에서 key값을 주지 않으면 경고가 뜬다.
- 이때, key 값으로 index를 주어서는 안된다.
- key 값이 필요한 이유는, key값을 비교할 때 항목의 변화를 식별하는 기준이 된다.
- 이때 index를 key로 사용하면, 항목 순서가 바뀔 경우 실제 DOM 업데이트가 정확하지 않을 수 있음.
- key는 리스트 내 항목 사이의 순서나 정체성을 안정적으로 비교하기 위해 존재한다.

### ❓ 리스트에서는 key로 비교한다면, 단일 컴포넌트의 변화는 어떻게 인식할 수 있을까? 단일 컴포넌트에서는 key값이 필요하지 않을까? DOM vs VDOM. 이 둘은 어떻게 서로를 비교하는가?

#### 🧠 결론

단일 컴포넌트와 리스트 렌더링에서 어떻게 DOM과 VDOM을 비교하는지 알아보고, [해당 질문](#-리스트에서는-key로-비교하고-단일-컴포넌트에-key-값이-존재하지-않는다면-dom-vs-vdom-이-둘은-어떻게-서로를-비교하는가) 를 2주차 스터디에서 서브미션으로 다루기

---

## [조건부 렌더링](https://ko.react.dev/learn/conditional-rendering)

### ✅ 학습 내용 요약

#### 📌 조건에 따라 다른 JSX를 반환하는 방법

- 조건문
- 삼항연산자

#### 📌 JSX 조각을 조건부로 표현하거나 제외하는 방법

- `&&`의 왼쪽에 숫자를 두지 않기
  - `"토끼" && "호랑이"`
    - "토끼"는 truthy, "호랑이"도 truthy => 마지막 값 반환
  - `0 && "호랑이"`
    - 0은 falsy 이므로 첫 값 반환

#### 📌 React 코드에서 흔히 볼 수 있는 조건부 문법

---

## [리스트 렌더링](https://ko.react.dev/learn/rendering-lists)

해당 내용들은 [컴포넌트에 Props 전달하기 서브주제 질문](#-리스트에서는-key로-비교하고-단일-컴포넌트에-key-값이-존재하지-않는다면-dom-vs-vdom-이-둘은-어떻게-서로를-비교하는가)을 참고

#### 📌 JavaScript map()을 사용하여 배열을 컴포넌트로 렌더링하는 방법

#### 📌 avaScript의 filter()를 사용하여 특정 컴포넌트만 렌더링하는 방법

#### 📌 React에서 Key가 필요한 때와 이유

---

## [컴포넌트를 순수하게 유지하기](https://ko.react.dev/learn/keeping-components-pure)

### ✅ 학습 내용 요약

#### 📌 순수성이란 무엇인지 그리고 어떻게 버그를 피하는가

- 순수성
  - side-effect가 없는 것
  - 같은 값이 들어가면 같은 결과가 나오는 것

#### 📌 렌더 단계에서 변화를 유지하면서 컴포넌트를 순수하게 유지하기

#### 📌 엄격 모드를 어떻게 활용해서 컴포넌트에 실수를 발견할 수 있는가

- Strict Mode에서 2번씩 렌더링 -> 두 결과값이 다르면 순수하지 않다.
- props, state, context는 읽기 전용이어야 한다. -> 바꿀 수 없다.
- Strict Mode는 개발 환경에서만 동작한다.

### 📌 이벤트 핸들러의 순수성

- 이벤트 핸들러는 순수할 필요가 없다.
- 함수형 프로그래밍은 순수성에 크게 의존하지만, 언젠가는 어딘가에서 무언가가 바뀌어야 한다.
  - 여기서 `언젠가`가 side-effect ?
  - 사이드 이펙트가 발생하는 시점은 evet, useEffect 라고 생각한다.
  - 공식문서에서는 화면 업데이트, 애니메이션 시작, 데이터 변경을 사이드 이펙트라고 한다.

### ❓ 컴포넌트 내에서 props를 변경할 수 있을까?

#### 📎 토론 내용

```javascript
const Button = ({ text, onClick = () => {} }: ButtonProps) => {
  text = "hello";
  console.log(text);
  return (
    <button className={`${styles.button} `} type="submit" onClick={onClick}>
      {text}
    </button>
  );
};
```

여기서 text = 'hello'는 props로 전달된 값을 복사한 지역 변수 text를 재할당하는 것.
이건 함수 인자(구조분해)로 받은 text의 지역 변수를 덮어쓰는 것이지, 원래의 props 객체나 부모 컴포넌트의 상태를 변경하는 것은 아니다.

### ❓ 사이드 이펙트란 정확하게 무엇을 말하는가?

#### 📎 토론 내용

- 사이드 이펙트 == 렌더링 이후에 일어나는 이벤트?
- 사이드 이펙트란 무엇인가?
  - 어떤 함수가 외부 상태를 변경하거나, 외부에 영향을 주는 행위
  - DOM 변경, 서버ㅓ 요청, 콘솔 로그 state 변경, 로컬 스토리지 저장 등

#### 🧠 결론

사이드 이팩트가 무엇인지에 대해서 공부해오고, 2주차 스터디에서 서브 주제로 공유하기

---

## [트리로서 UI 이해하기](https://ko.react.dev/learn/understanding-your-ui-as-a-tree)

### ✅ 학습 내용 요약

#### 📌 React가 컴포넌트 구조를 "이해하는" 방법

- 트리를 그려서
- 부모 - 자식 관계로 이해 한다.

#### 📌 렌더 트리가 무엇이고 어떤 용도로 사용되는지 (렌더링 시점의 컴포넌트 구조)

- 렌더링 관련된 트리
- 컴포넌트 렌더링하기 위해서
- 리액트 컴포넌트로만 구성된 트리
- 리프 노드 : 컴포넌트

#### 📌 모듈 의존성 트리가 무엇이고 어떤 용도로 사용되는지 (빌드 시점의 코드 구조)

- 함수, 훅을 모두 포함한다.
- 배포 목적으로 배포할 때, 필요한 모든 JS 코드를 하나의 파일로 묶는 번들러에 의해 사용

---

## 회고

- 머핀

  - 읽으면서 약간 "당연하지~"하면서 읽었다. 토론할게 많지 않을 것 같았다.
    그런데, 이야기를 나눠보니까 "다들 의심을 하면서 읽네?" 이런 생각을 들면서 놓친 부분을 이야기하면서 챙겨 나가는 느낌이 들었다. 그래서 좋았다.

- 메타

  - 꿀잼 스터디다. 여기 사람들 좋은 것 같다. 당연하다고 생각하고 읽었는데, 다들 의심하는게 신기해서 배워야 겠다고 생각했다. 사람들이 따뜻하고 혼자 읽을 때는 안궁금했는데, 읽다보니 의심되는게 많았다. (렌더링 되는 것, key 값 돌리는 것)

- 캉골

  - 처음 두 장까지는 당연히 아는 내용이라고 생각했다. 그런데, 맨 처음 질문들에 대해서 "답변이 뭐지?"하는 순간이 있어서 반성했다. 제대로 읽어야겠다고 생각하였다. 생각보다 모르는게 많다고 느꼈고, 꼬리 질문이 많다고 생각해서 열심히 해야겠다고 느꼈다.

- 해삐

  - 처음에 읽을 때는 "오 ~ 맞지 맞네 그렇지"하고 파고 들 수 있었다. useEffect, side-effect에서 "내가 알고 있던게 아니었나?"라는 생각이 들기도 했다.

- 헤일리

  - 읽을 때는 빨리 읽었는데, 대화해보니까 정확히 이해하지 않는 부분이 있었다. 생각해보니까 왜 map 안 쓰고 컴포넌트 만들 때는 key 값을 안쓰지?

- 퐁주

  - 혼자 읽었으면 별 생각 없이 공식문서를 읽었을 것 같다. 스터디를 하길 잘한 것 같다. 첮 장이라 양이 많아도 할만할 것 같았는데, 페프 끝나고 읽으려니 힘들었다. 다같이 고민하는 시간을 가지니까 머릿속에 오래 남을 것 같다.

- 상추
  - 정말 혼자 읽었으면 제대로 안 읽었을 것 같다. 딱 당장 필요한 부분만 읽었을 것 같다.
    그리고 읽었을 때는 그냥 납드이 되는 내용들이었는데, 스터디를 진행하는데 다들 의심을 가지고 "왜 그렇게 되지?"를 꺼내고 이야기하는 과정에서 생각치 못한 포인트들을 파고 들 수 있었다.
    혼자 읽는 것을 틀로 잡아, 다같이 고민하고 이야기함녀서 틀의 내부가 채워지는 것 같아 재미있다.
    다음 부터는 궁금한점, 의심이 되는 부분들을 한 뎁스라도 더 깊게 파서 읽어 봐야겠다고 생각했다.
    준의 가추법을 적용해볼까?

## 다음주까지

[서브 주제 1](#-react는-컴포넌트로만-이루어진-것일까)
[서브 주제 2](#-리스트에서는-key로-비교하고-단일-컴포넌트에-key-값이-존재하지-않는다면-dom-vs-vdom-이-둘은-어떻게-서로를-비교하는가)
[서브 주제 3](#-사이드-이펙트란-정확하게-무엇을-말하는가)
